#include "modules/Network/NetConf.hpp"
#include "libs/buffers.hpp"
#include "libs/p2b/core.hpp"
#include "libs/p2b/bitmap.hpp"

#include "modules/Threading/CaptureThread.hpp"

#include <boost/interprocess/creation_tags.hpp>
#include <cstddef>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <opencv2/core/hal/interface.h>
#include <opencv4/opencv2/highgui.hpp>
#include <opencv4/opencv2/core/mat.hpp>
#include <sys/types.h>
#include <thread>

#include <boost/interprocess/shared_memory_object.hpp>
#include <boost/interprocess/mapped_region.hpp>
#include <vector>

using namespace std;
using namespace boost::interprocess;

//? Multithread experiment with FIFOBuffer


//? Test thread class to experiment with a bitmap
class BitmapThread {

    private:
        p2b::Bitmap frame_bitmap;

        const char* shmem_name;
        size_t shmem_size;
        int shmem_n_frames;
        int frame_height;
        int frame_width;

        shared_memory_object shmem;
        mapped_region mem_region;
        uint8_t* shmem_ptr;

    public:

        BitmapThread(
            const char* shmem_name,
            const size_t shmem_size,
            const int shmem_n_frames,
            const int frame_height,
            const int frame_width
        ){
            this->frame_bitmap = p2b::Bitmap(
                800,
                200,
                2,
                {85, 170, 255}
            );
            
            this->shmem_name = shmem_name;
            this->shmem_size = shmem_size;
            this->shmem_n_frames = shmem_n_frames;
            this->frame_height = frame_height;
            this->frame_width = frame_width;

            this->shmem = shared_memory_object(
                open_only,
                this->shmem_name,
                read_write
            );
            this->mem_region = mapped_region(this->shmem, read_write);
            this->shmem_ptr = (uint8_t*) mem_region.get_address();

        }
        
        ~BitmapThread(){
            shared_memory_object::remove(this->shmem_name);
        }
        

        // Thread start method
        void start(){

            const int FRAME_SIZE = this->frame_height * this->frame_width;
            const int TOTAL_SHMEM_MSG_SIZE = sizeof(struct ShmemFrameMessage) + FRAME_SIZE;

            cout << "---- BITMAP THREAD STARTED ----" << endl;

            cv::namedWindow(
                "Bitmap visualization",
                cv::WINDOW_NORMAL | cv::WINDOW_KEEPRATIO | cv::WINDOW_GUI_EXPANDED
            );
            cv::resizeWindow("Bitmap visualization", 800, 800);
            cv::Mat outImg;

            this->frame_bitmap.toGrayscaleImage_parallel(
                &outImg, 
                {85,170,255}
            );

            // Main loop        
            while(1){

                cv::imshow("Bitmap visualization", outImg);
                
                //? The sync byte is not 0
                if (!isShmemEmpty(this->shmem_ptr, this->shmem_size)){

                    //? Signal to end thread
                    if (*this->shmem_ptr == 255){
                        goto END;
                    }

                    cv::Mat tmp_img;
                    ShmemFrameMessage* tmp_msg = new ShmemFrameMessage;
                    size_t shmem_read_bytes = 0;
                    uint8_t* tmp_data = (uint8_t*) malloc(FRAME_SIZE);
                    for(int i=0; i<this->shmem_n_frames; ++i){
                        
                        std::memcpy(
                            tmp_msg,
                            this->shmem_ptr+shmem_read_bytes,
                            sizeof(struct ShmemFrameMessage)
                        );
                        //*tmp_msg = (ShmemFrameMessage) *(this->shmem_ptr+shmem_read_bytes);

                        
                        std::memcpy(
                            tmp_data,
                            this->shmem_ptr+shmem_read_bytes+sizeof(struct ShmemFrameMessage),
                            FRAME_SIZE
                        );
                        //*tmp_data = *(this->shmem_ptr+shmem_read_bytes+sizeof(struct ShmemFrameMessage));

                        shmem_read_bytes += TOTAL_SHMEM_MSG_SIZE;

                        tmp_img = cv::Mat(
                            this->frame_height,
                            this->frame_width,
                            CV_8UC1,
                            tmp_data
                        );

                        this->frame_bitmap.addImage(
                            &tmp_img, 
                            tmp_msg->add_direction, 
                            true
                        );
                    }
                    free(tmp_data);

                    this->frame_bitmap.toGrayscaleImage_parallel(
                        &outImg, 
                        {85,170,255}
                    );

                    //? Emptying shmem
                    memset(this->shmem_ptr, 0, this->shmem_size);
                }

            }


            END:
            cv::destroyAllWindows();
            cout << "BITMAP_THREAD: Stopped" << endl;

        }

};













int Threading_demo(){
    
    //? Constant parameters ----------------------
    const int FRAME_WIDTH = 640;
    const int FRAME_HEIGHT = 480;

    const int FRAME_SIZE = FRAME_HEIGHT * FRAME_WIDTH;
    const long INITIAL_BUFFER_CAPACITY = 16;
    const char* SHMEM_NAME = "frame_shmem";
    const int SHMEM_N_FRAMES = 3;
    const size_t SHMEM_SIZE = SHMEM_N_FRAMES * (FRAME_SIZE + sizeof(struct ShmemFrameMessage));
    //const size_t SHMEM_SIZE = 10'000'000;   //! 10 MiB
    //? ------------------------------------------

    //! SHMEM REMOVER, REALLY IMPORTANT
    struct shm_remove
    {   //! Can't use shmem_name var here, hard coded name
        shm_remove() { shared_memory_object::remove("frame_shmem"); }
        ~shm_remove(){ shared_memory_object::remove("frame_shmem"); }
    } remover;

    //? Shmem init
    shared_memory_object shmem = shared_memory_object(
        create_only, SHMEM_NAME, read_write
    );
    shmem.truncate(SHMEM_SIZE);
    mapped_region mem_region = mapped_region(
        shmem, read_write
    );
    memset(mem_region.get_address(), 0, SHMEM_SIZE);

    //? Thread classes init
    CaptureThread capThread = CaptureThread(
        INITIAL_BUFFER_CAPACITY,
        SHMEM_NAME,
        SHMEM_SIZE,
        SHMEM_N_FRAMES,
        FRAME_HEIGHT,
        FRAME_WIDTH
    );

    BitmapThread bmpThread = BitmapThread(
        SHMEM_NAME,
        SHMEM_SIZE,
        SHMEM_N_FRAMES,
        FRAME_HEIGHT,
        FRAME_WIDTH
    );

    //? Thread starts
    thread capture_thread = thread(&CaptureThread::start, &capThread);
    thread bitmap_thread = thread(&BitmapThread::start, &bmpThread);

    //? Thread join
    capture_thread.join();
    bitmap_thread.join();

    return 0;
}
